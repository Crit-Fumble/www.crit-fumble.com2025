/**
 * Server Management Commands
 * Commands for managing Discord server settings, roles, channels
 */

import {
  SlashCommandBuilder,
  EmbedBuilder,
  PermissionFlagsBits,
  ChannelType,
  type ChatInputCommandInteraction,
  type TextChannel,
  type VoiceChannel,
} from 'discord.js'
import type { FumbleBotClient } from '../../client.js'

// Define slash commands
export const serverCommands = [
  new SlashCommandBuilder()
    .setName('server')
    .setDescription('Server management commands')
    .setDefaultMemberPermissions(PermissionFlagsBits.ManageGuild)
    .addSubcommand((subcommand) =>
      subcommand
        .setName('info')
        .setDescription('Get server information')
    )
    .addSubcommand((subcommand) =>
      subcommand
        .setName('stats')
        .setDescription('Get server statistics')
    )
    .addSubcommand((subcommand) =>
      subcommand
        .setName('announce')
        .setDescription('Send an announcement to a channel')
        .addChannelOption((option) =>
          option
            .setName('channel')
            .setDescription('Channel to announce in')
            .setRequired(true)
            .addChannelTypes(ChannelType.GuildText, ChannelType.GuildAnnouncement)
        )
        .addStringOption((option) =>
          option
            .setName('message')
            .setDescription('Announcement message')
            .setRequired(true)
        )
        .addStringOption((option) =>
          option
            .setName('title')
            .setDescription('Announcement title')
            .setRequired(false)
        )
    )
    .addSubcommand((subcommand) =>
      subcommand
        .setName('welcome')
        .setDescription('Set up or view welcome message settings')
        .addChannelOption((option) =>
          option
            .setName('channel')
            .setDescription('Channel for welcome messages')
            .setRequired(false)
            .addChannelTypes(ChannelType.GuildText)
        )
        .addStringOption((option) =>
          option
            .setName('message')
            .setDescription('Welcome message (use {user} for mention, {server} for server name)')
            .setRequired(false)
        )
    )
    .addSubcommand((subcommand) =>
      subcommand
        .setName('cleanup')
        .setDescription('Delete messages from a channel')
        .addIntegerOption((option) =>
          option
            .setName('count')
            .setDescription('Number of messages to delete (1-100)')
            .setRequired(true)
            .setMinValue(1)
            .setMaxValue(100)
        )
        .addUserOption((option) =>
          option
            .setName('user')
            .setDescription('Only delete messages from this user')
            .setRequired(false)
        )
    ),

  new SlashCommandBuilder()
    .setName('role')
    .setDescription('Role management commands')
    .setDefaultMemberPermissions(PermissionFlagsBits.ManageRoles)
    .addSubcommand((subcommand) =>
      subcommand
        .setName('give')
        .setDescription('Give a role to a user')
        .addUserOption((option) =>
          option.setName('user').setDescription('User to give role to').setRequired(true)
        )
        .addRoleOption((option) =>
          option.setName('role').setDescription('Role to give').setRequired(true)
        )
    )
    .addSubcommand((subcommand) =>
      subcommand
        .setName('remove')
        .setDescription('Remove a role from a user')
        .addUserOption((option) =>
          option.setName('user').setDescription('User to remove role from').setRequired(true)
        )
        .addRoleOption((option) =>
          option.setName('role').setDescription('Role to remove').setRequired(true)
        )
    )
    .addSubcommand((subcommand) =>
      subcommand
        .setName('list')
        .setDescription('List all roles in the server')
    )
    .addSubcommand((subcommand) =>
      subcommand
        .setName('info')
        .setDescription('Get information about a role')
        .addRoleOption((option) =>
          option.setName('role').setDescription('Role to get info about').setRequired(true)
        )
    ),
]

// Command handler
export async function serverHandler(
  interaction: ChatInputCommandInteraction,
  _bot: FumbleBotClient
): Promise<void> {
  const commandName = interaction.commandName
  const subcommand = interaction.options.getSubcommand()

  if (!interaction.guild) {
    await interaction.reply({
      content: '‚ùå This command can only be used in a server.',
      ephemeral: true,
    })
    return
  }

  try {
    if (commandName === 'server') {
      if (subcommand === 'info') {
        const guild = interaction.guild

        const embed = new EmbedBuilder()
          .setColor(0x7c3aed)
          .setTitle(guild.name)
          .setThumbnail(guild.iconURL({ size: 256 }))
          .addFields(
            { name: 'Owner', value: `<@${guild.ownerId}>`, inline: true },
            { name: 'Created', value: `<t:${Math.floor(guild.createdTimestamp / 1000)}:R>`, inline: true },
            { name: 'Members', value: `${guild.memberCount}`, inline: true },
            { name: 'Channels', value: `${guild.channels.cache.size}`, inline: true },
            { name: 'Roles', value: `${guild.roles.cache.size}`, inline: true },
            { name: 'Boosts', value: `${guild.premiumSubscriptionCount || 0}`, inline: true }
          )
          .setFooter({ text: `Server ID: ${guild.id}` })
          .setTimestamp()

        if (guild.description) {
          embed.setDescription(guild.description)
        }

        await interaction.reply({ embeds: [embed] })
      } else if (subcommand === 'stats') {
        const guild = interaction.guild
        await guild.members.fetch()

        const textChannels = guild.channels.cache.filter(
          (c) => c.type === ChannelType.GuildText
        ).size
        const voiceChannels = guild.channels.cache.filter(
          (c) => c.type === ChannelType.GuildVoice
        ).size
        const categories = guild.channels.cache.filter(
          (c) => c.type === ChannelType.GuildCategory
        ).size

        const onlineMembers = guild.members.cache.filter(
          (m) => m.presence?.status !== 'offline' && m.presence?.status !== undefined
        ).size
        const bots = guild.members.cache.filter((m) => m.user.bot).size
        const humans = guild.memberCount - bots

        const embed = new EmbedBuilder()
          .setColor(0x7c3aed)
          .setTitle(`üìä ${guild.name} Statistics`)
          .addFields(
            { name: 'üë• Members', value: `Total: ${guild.memberCount}\nHumans: ${humans}\nBots: ${bots}\nOnline: ${onlineMembers}`, inline: true },
            { name: 'üì∫ Channels', value: `Text: ${textChannels}\nVoice: ${voiceChannels}\nCategories: ${categories}`, inline: true },
            { name: 'üé≠ Roles', value: `${guild.roles.cache.size}`, inline: true },
            { name: 'üòÄ Emojis', value: `${guild.emojis.cache.size}`, inline: true },
            { name: '‚ú® Stickers', value: `${guild.stickers.cache.size}`, inline: true },
            { name: 'üíé Boost Level', value: `Level ${guild.premiumTier}`, inline: true }
          )
          .setTimestamp()

        await interaction.reply({ embeds: [embed] })
      } else if (subcommand === 'announce') {
        const channel = interaction.options.getChannel('channel', true) as TextChannel
        const message = interaction.options.getString('message', true)
        const title = interaction.options.getString('title')

        const embed = new EmbedBuilder()
          .setColor(0xeab308)
          .setDescription(message)
          .setTimestamp()
          .setFooter({ text: `Announced by ${interaction.user.tag}` })

        if (title) {
          embed.setTitle(`üì¢ ${title}`)
        }

        await channel.send({ embeds: [embed] })
        await interaction.reply({
          content: `‚úÖ Announcement sent to ${channel}`,
          ephemeral: true,
        })
      } else if (subcommand === 'welcome') {
        const channel = interaction.options.getChannel('channel')
        const message = interaction.options.getString('message')

        // TODO: Store welcome settings in database
        if (!channel && !message) {
          await interaction.reply({
            content: 'üìù Welcome message settings:\n- Channel: Not set\n- Message: Not set\n\nUse `/server welcome channel:#channel message:Your welcome message` to configure.',
            ephemeral: true,
          })
        } else {
          await interaction.reply({
            content: `‚úÖ Welcome settings updated!\n- Channel: ${channel || 'unchanged'}\n- Message: ${message || 'unchanged'}`,
            ephemeral: true,
          })
        }
      } else if (subcommand === 'cleanup') {
        const count = interaction.options.getInteger('count', true)
        const targetUser = interaction.options.getUser('user')

        const channel = interaction.channel as TextChannel

        if (!channel.isTextBased()) {
          await interaction.reply({
            content: '‚ùå This command can only be used in text channels.',
            ephemeral: true,
          })
          return
        }

        await interaction.deferReply({ ephemeral: true })

        const messages = await channel.messages.fetch({ limit: 100 })
        let filtered = messages.filter(
          (m) => Date.now() - m.createdTimestamp < 14 * 24 * 60 * 60 * 1000 // 14 days
        )

        if (targetUser) {
          filtered = filtered.filter((m) => m.author.id === targetUser.id)
        }

        const toDelete = filtered.first(count)

        if (toDelete.length === 0) {
          await interaction.editReply({
            content: '‚ùå No messages found to delete.',
          })
          return
        }

        const deleted = await channel.bulkDelete(toDelete, true)
        await interaction.editReply({
          content: `‚úÖ Deleted ${deleted.size} messages.`,
        })
      }
    } else if (commandName === 'role') {
      if (subcommand === 'give') {
        const user = interaction.options.getUser('user', true)
        const role = interaction.options.getRole('role', true)

        const member = await interaction.guild.members.fetch(user.id)
        await member.roles.add(role.id)

        await interaction.reply({
          content: `‚úÖ Gave ${role} to ${user}`,
          ephemeral: true,
        })
      } else if (subcommand === 'remove') {
        const user = interaction.options.getUser('user', true)
        const role = interaction.options.getRole('role', true)

        const member = await interaction.guild.members.fetch(user.id)
        await member.roles.remove(role.id)

        await interaction.reply({
          content: `‚úÖ Removed ${role} from ${user}`,
          ephemeral: true,
        })
      } else if (subcommand === 'list') {
        const roles = interaction.guild.roles.cache
          .sort((a, b) => b.position - a.position)
          .filter((r) => r.id !== interaction.guild!.id)
          .map((r) => `${r} (${r.members.size} members)`)
          .slice(0, 25)
          .join('\n')

        const embed = new EmbedBuilder()
          .setColor(0x7c3aed)
          .setTitle('Server Roles')
          .setDescription(roles || 'No roles found')
          .setFooter({ text: `Total: ${interaction.guild.roles.cache.size - 1} roles` })

        await interaction.reply({ embeds: [embed], ephemeral: true })
      } else if (subcommand === 'info') {
        const role = interaction.options.getRole('role', true)

        const embed = new EmbedBuilder()
          .setColor(role.color || 0x7c3aed)
          .setTitle(role.name)
          .addFields(
            { name: 'Color', value: role.hexColor, inline: true },
            { name: 'Position', value: `${role.position}`, inline: true },
            { name: 'Members', value: `${role.members.size}`, inline: true },
            { name: 'Mentionable', value: role.mentionable ? 'Yes' : 'No', inline: true },
            { name: 'Hoisted', value: role.hoist ? 'Yes' : 'No', inline: true },
            { name: 'Managed', value: role.managed ? 'Yes' : 'No', inline: true }
          )
          .setFooter({ text: `Role ID: ${role.id}` })

        await interaction.reply({ embeds: [embed], ephemeral: true })
      }
    }
  } catch (error) {
    const errorMessage = error instanceof Error ? error.message : 'Command failed'
    const reply = interaction.deferred || interaction.replied
      ? interaction.editReply
      : interaction.reply

    await reply.call(interaction, {
      content: `‚ùå ${errorMessage}`,
      ephemeral: true,
    } as any)
  }
}
